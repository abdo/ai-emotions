# AI Show - Project Rules & Architecture

## Project Overview

**AI Show** is a React + TypeScript web application that creates cinematic, AI-generated conversations from user situations. It offers two distinct modes:
1.  **Story Mode**: A cinematic re-enactment of the user's situation ("Show, Don't Tell").
2.  **Conversation Mode**: A deep discussion/debate between friends about the situation.

It uses:
- **Groq AI** (`llama-3.3-70b-versatile`) for generating dramatic character dialogues
- **OpenAI TTS** (`gpt-4o-mini-tts`) for realistic, persona-based voice generation
- **React 18 + Vite + React Router** for modern SPA development

The app generates 3-6 distinct characters with unique voices, personalities, and perspectives, then plays their conversation as an animated theatrical experience.

---

## Tech Stack

### Core
- **Build Tool**: Vite
- **Language**: TypeScript (strict mode)
- **UI Framework**: React 18 (functional components only)
- **Routing**: React Router v6
- **Styling**: Plain CSS (co-located with components)
- **Animation**: GSAP (for ChromaGrid spotlight effects)
- **HTTP Client**: Axios

### AI Services
- **Text Generation**: Groq API (`llama-3.3-70b-versatile`)
- **Voice Synthesis**: OpenAI TTS API (`gpt-4o-mini-tts`)

### Key Libraries
- `ogl` - WebGL graphics (for ChromaGrid)
- `gsap` - Smooth animations
- `react-router-dom` - Client-side routing

---

## Architecture

### File Structure

```
src/
├── pages/                       # Route pages
│   ├── LandingPage/
│   │   ├── LandingPage.tsx      # Hero + input + mode switch (route: /)
│   │   └── LandingPage.css
│   └── TheatrePage/
│       ├── TheatrePage.tsx      # Theatre mode (route: /theatre)
│       └── TheatrePage.css
├── components/                   # Reusable UI components
│   ├── ChromaGrid/
│   │   ├── ChromaGrid.tsx       # Interactive character grid
│   │   └── ChromaGrid.css
│   ├── ModeSwitch/
│   │   ├── ModeSwitch.tsx       # Cookie-themed toggle (Story/Conversation)
│   │   └── ModeSwitch.css
│   └── VolumeControl/
│       ├── VolumeControl.tsx    # Audio volume slider
│       └── VolumeControl.css
├── ui/                          # UI primitives
│   └── icons/                   # SVG icon components
├── hooks/                       # Custom React hooks
│   ├── usePerspectives.ts       # Groq AI story generation (handles modes)
│   └── usePersonaVoices.ts      # OpenAI TTS voice management
├── constants/                   # Static configuration
│   ├── theatreCharacters.ts     # Character roles & voice config
│   ├── prompts.ts              # AI prompts (Shared + Mode-Specific)
│   └── demoData.ts             # Fallback/mock story data
├── lib/                        # Utility functions
│   ├── avatarConstants.ts      # Gender-specific avatar pools
│   ├── textCleaner.ts         # Text sanitization for TTS
│   └── audioUtils.ts          # Audio processing utilities
├── assets/
│   └── theatre.webp           # Landing page background
├── keys.ignore.ts             # API keys (NEVER COMMIT!)
├── App.tsx                    # Router setup
└── main.tsx                   # Entry point
```

### Routing

```
/ (LandingPage)
  → User enters situation + optional name
  → User selects Mode (Story vs Conversation)
  → Navigates to /theatre with state: { topic, mode, name }

/theatre (TheatrePage)
  → Fetches story from Groq using mode-specific prompt
  → Generates voices from OpenAI
  → Plays conversation
  → Redirects to / if no topic
```

---

## Key Concepts

### 1. Story Generation Flow

1.  User enters a situation on `/` (LandingPage)
2.  Navigate to `/theatre` with `{ state: { topic, mode, name } }`
3.  `usePerspectives` calls `storyGenerationPrompt(mode)` in `constants/prompts.ts`
4.  **Prompt Construction**:
    *   **Shared Instructions**: Character depth, roles, dialogue craft, JSON format.
    *   **Mode-Specific Framing**:
        *   *Story*: "Re-enact this scene", "Show don't tell", "In Media Res".
        *   *Conversation*: "Discuss this topic", "Debate", "Random Scenario".
    *   **Structure**:
        *   *Story*: Hook -> Action -> Fallout.
        *   *Conversation*: Act 1 -> Act 2 -> Act 3.
5.  AI returns JSON with characters and dialogue.

### 2. Modes

**Story Mode (Default)**
*   **Goal**: Cinematic re-enactment of the event.
*   **Prompting**: Enforces "Show, Don't Tell". Starts *in media res* (in the middle of action).
*   **Structure**: Hook -> Action -> Fallout.
*   **User Inclusion**: Only included if they are a direct participant in the scene.

**Conversation Mode**
*   **Goal**: Friends discussing/debating the event.
*   **Prompting**: Discussing *about* the user's situation.
*   **Structure**: Act 1 (Opening) -> Act 2 (Conflict) -> Act 3 (Climax).
*   **Dynamics**: Injects a random "Conversation Scenario" (e.g., "Devil's Advocate", "Unexpected Agreement") to keep discussions fresh.

### 3. Voice System

**20 Standardized Roles** (defined in `constants/theatreCharacters.ts`):
- Single source of truth: `roleDescriptions` object
- Roles: empathetic, analytical, provocateur, emotional, calm, assertive, skeptical, optimistic, cynical, nurturing, intense, playful, serious, wise, rebellious, mediator, challenger, supporter, observer, wildcard

Each role maps to:
- **Instructions** for OpenAI TTS (e.g., "raw, expressive, passionate")
- **Voice pool** by gender (Onyx, Ash, Echo, Alloy, Nova, Shimmer, Sage, Coral)

**Voice Selection Logic**:
- Tracks `usedVoices` Set per story generation
- Picks from unused voices first (to avoid repetition)
- Falls back to random if all voices exhausted

### 4. Text-to-Speech Pipeline

1.  User clicks "Start the show"
2.  Browser requests user interaction (autoplay policy bypass)
3.  `usePersonaVoices` generates all voices in parallel:
    - Cleans text via `lib/textCleaner.ts` (removes markdown, emojis, stage directions)
    - Calls OpenAI TTS with role-based instructions
    - Converts response to base64 `data:audio/mp3` URI
4.  Plays dialogue sequentially with 100ms gap between lines
5.  First audio has 600ms delay to prevent cutoff
6.  Highlights speaking character in ChromaGrid

---

## Coding Standards

### TypeScript

- **No `any`** - use `unknown` or proper types
- **Explicit prop types** for all components
- **Named exports** preferred
- **Derive types from data** when possible (single source of truth)

### React Patterns

- **Functional components only**
- **Hooks**: `useState`, `useEffect`, `useCallback`, `useMemo`, `useRef`
- **React Router** for navigation (use `navigate()`, `useLocation()`)

### State Management

- **React hooks** for local state
- **React Router state** for page-to-page data passing (topic, mode, name)

### Styling

- **Plain CSS files** co-located with components
- **Component-scoped classes**
- **CSS custom properties** for theming
- **Responsive**: use `clamp()`, `vw`, media queries

---

## AI Configuration

### Groq Story Generation

**Prompt Location**: `src/constants/prompts.ts`

**Architecture**:
The prompt is dynamically assembled based on the selected `mode`:

1.  **Framing**:
    *   *Story*: "You are re-enacting..."
    *   *Conversation*: "You are discussing..."
2.  **Structure**:
    *   *Story*: Cinematic Pacing (Hook -> Action -> Fallout)
    *   *Conversation*: Discussion Arc (Act 1 -> Act 2 -> Act 3)
3.  **Scenarios (Conversation Only)**:
    *   Injects a random conversation pattern (e.g., "One person plays devil's advocate")
4.  **Shared Instructions**:
    *   Character Depth & Roles
    *   Dialogue Craft (Realism, Interruptions)
    *   Tone Annotations (`[angry]`, `[whispering]`)
    *   JSON Output Format

**Output**: JSON with `characters[]` and `dialogue[]`

### OpenAI TTS Configuration

**Voice Config Location**: `src/constants/theatreCharacters.ts`
- `roleDescriptions` - Single source of truth for all roles
- `maleVoices` / `femaleVoices` - Voice ID arrays

---

## Common Patterns

### Adding a New Character Role
1.  Add to `roleDescriptions` in `src/constants/theatreCharacters.ts`
2.  That's it! Types and prompts update automatically.

### Adding a New Voice
1.  Add to `maleVoices` or `femaleVoices` in `src/constants/theatreCharacters.ts`

### Debugging
- **Voice Issues**: Check console for `[Voice N]...` logs.
- **Prompt Issues**: Check `prompts.ts` - ensure shared vs specific logic is correct.
- **Routing**: Ensure `mode` is passed in `navigate` state.

---

## Important Files

| File | Purpose | Notes |
|------|---------|-------|
| `keys.ignore.ts` | API keys | Never commit |
| `constants/prompts.ts` | AI prompts | **CRITICAL**: Handles mode logic |
| `constants/theatreCharacters.ts` | Role system | Single source of truth |
| `hooks/usePerspectives.ts` | Story fetching | Handles Groq API & Mode |
| `components/ModeSwitch/` | UI Toggle | "Cookie" switch implementation |

---

**Last Updated**: November 2024
